>   Упакованные блоки имеют заголовок:
>
>+0 "HR".
>+2 распакованная длина.
>+4 упакованная длина (всего файла вместе с этим заголовком).
>+6 шесть последних байт блока.
>+12 два байта начала битового потока.
>+13 первый байт блока.
>+14 сами упакованные данные.

1. пакуется весь файл без последних 6 байт, которые вон вверху
2. сначала при распаковке выбирается 16 бит битпотока, потом байт,
который безусловно копируется в выход, потом начинается обычная
работа (выборка битов и байтов по мере необходимости)


обозначение вроде %abcd<byte1>xyz<byte2>
означает, что сначала из битпотока выбираются биты abcd (при необходимости
новые 2 байта засасываются), потом из байт-потока byte1, потом снова биты xyz,
потом byte2

Запись %xyz: - битовый префикс, далее идёт описание дальнейшей последовательности с табуляциями.

Запись %xyz, - конец описания дерева выборов.


Ссылки отсчитываются от текущего байта: который только предстоит заполнить чем-либо, на
который указывает указатель.

запись вида [abc] - обозначает беззнаковое число, составленное из битов a,b и c,
выровненных вправо.

запись вида ( A | B | C ) - выбор одного из вариантов A, B или C, условия указаны в тексте

смещение задаётся 2-байтовым числом, которое прибавляется к адресу текущего байта:
например смещение FFFF обозначает смещение на 1 байт взад (на последний уже записанный в выход
байт)

Расширяющяяся ссылка - ссылка, в которой выбираются 2-8 бит старшего байта смещения.
Изначально выбираются 2 бита, после каждого расширения - будет выбираться на 1 бит больше.
Расширений может быть, соответственно, не более 6 штук. Реализуется это (в депакере на Z80)
путём начальной установки D' в $BF, и при каждом расширении - RRC D. Считаются биты так:
LD A,D:<get bit in C>:RLA:JR C,<bit in C>. Для $BF - 2 бита, $DF - 3 бита, ..., $FE - 8 бит.



%1<byte>, копировать byte в выход.

%000abc, длина 1 байт, смещение FFF8+[abc].

%001: длина 2 байта,
    %00<byte>, смещение FD00+<byte>.

    %01<byte>, смещение FE00+<byte>.

    %10<byte>:
             если $00 < byte < $E0, то смещение FF00+<byte> (FF00..FFDF).

             если $E0 <= byte <= $FF, temp = 1 + (byte<<<1)^$02, если temp==0 (byte==fe), то расширение (в выход ничего не пишется).
                                                                 если temp!=0, то выбрать <byte2>,
                                                                 смещение FF00+<temp-16> (FFB2,FFB4,...,FFEC,FFEE),
                                                                 в выход байт ссылке, <byte2>, байт по ссылке+2.
=====================================
e0,e1,e2,e3,...,fc,fd,fe,ff >rlca>
c1,c3,c5,c7,...,f9,fb,fd,ff >xor 2>
c3,c1,c7,c5,...,fb,f9,ff,fd >inc>
c4,c2,c8,c6,...,fc,fa,00,fe >sub $10>
b4,b2,b8,b6,...,ec,ea,xx,ee
=====================================

    %11abcde, смещение FFE0+[abcde].



%010: длина 3 байта,

    %00<byte>, смещение FE00+<byte>.

    %01<byte>:
             если $00 < byte < $E0, то смещение FF00+<byte> (FF00..FFDF).

             если $E0 <= byte <= $FF, temp = 1 + (byte<<<1)^$03, выбрать <byte2>,
                                                                 смещение FF00+<temp-16> (FFB1,FFB3,...,FFED,FFEF),
                                                                 в выход байт ссылке, <byte2>, байт по ссылке+2.
=====================================
e0,e1,e2,e3,...,fc,fd,fe,ff >rlca>
c1,c3,c5,c7,...,f9,fb,fd,ff >xor 3>
c2,c0,c6,c4,...,fa,f8,fe,fc >inc>
c3,c1,c7,c5,...,fb,f9,ff,fd >sub $10>
b3,b1,b7,b5,...,eb,e9,ef,ed
=====================================


    %10abcde, смещение FFE0+[abcde].

    %11ab<byte>..%11abcdefgh<byte>, выбрать ab..abcdefgh из битов (в зависимости от длины расширяющейся ссылки),
                                    смещение [ abcdefgh | 1abcdefg | 11abcdef | ... | 111111ab ]*256+<byte>,
                                    последовательность ab ... abcdefgh НЕ МОЖЕТ быть вся из единичных битов.



префиксы кодирования длин 4-15:

%01101 - 4
%01110 - 5
%0111100 - 6
%0111101 - 7
%0111110 - 8
%011111100 - 9
%011111101 - 10
%011111110 - 11
%01111111100 - 12
%01111111101 - 13
%01111111110 - 14
%01111111111 - 15

далее читаются 2 бита и обрабатываются, как в случае префикса %010.



%0110000abcdefg, [abcdefg]<15, len=[abcdefg]*256+<byte>, далее читаются %xy и как в %010
                 [abcdefg]==15, конец распаковки
                 [abcdefg]>15, len=[abcdefg], далее читаются %xy и как в %010

%0110001abcd, копировать (06+[abcd])*2 байт из входа в выход.

%011001abcd<byte>, смещение FFF0+[abcd], в выход байт по ссылке, <byte>, байт по ссылке+2




Классификация ссылок:

1. Копировать 1 байт в выход,

%1<byte>.


2. Копировать 12,14,16,...,40,42 байта в выход,

%0110001abcd<byte1>..<byteN>, N=(06+[abcd])*2.


3. ccылка длиной 1 байт, смещения FFF8..FFFF (-1..-8)

%000abc, смещение FFF8+[abc].


4. ссылка длиной 2 байта, смещения FD00..FFFF (-1..-768)

%00100<byte>, смещение FD00+<byte>,
%00101<byte>, смещение FE00+<byte>,
%00110<byte>, смещения FF00+<byte> (FF00..FFDF, <byte>=00..DF),
%00111abcde, смещение FFE0+[abcde].


5. ссылка длиной 3 байта, вставная, смещения FFB1..FFFF (-1..-79)

В выход копируется байт по смещению, потом байт из входного потока, потом байт по смещению+2

смещения FFB2,FFB4,FFB6,...,FFEE,
%00110<byte>, byte=E0,E1,E2,...,FC,FD,FF, temp=(byte<<<1)^$02 - 15, смещенине FF00+<temp>,

смещения FFB1,FFB3,FFB5,...FFEF,
%01001<byte>, byte=E0,E1,E2,...,FF, temp=(byte<<<1)^$03 - 15, cмещение FF00+<temp>,

смещения FFF0..FFFF,
%011001abcd, смещение FFF0+[abcd],

после выборки кода смещения из входного потока выбирается <byte2> и копируется в середину выхода,
как описано выше.


6. ссылки обычные длиной 3..3839 (0003..0EFF), смещенем -1..-65536 (0000..FFFF)

Сначала кодируется длина

кодирование длин 3..15:
%010 - 3
%01101 - 4
%01110 - 5
%0111100 - 6
%0111101 - 7
%0111110 - 8
%011111100 - 9
%011111101 - 10
%011111110 - 11
%01111111100 - 12
%01111111101 - 13
%01111111110 - 14
%01111111111 - 15

кодирование длин 16..127:
%0110000abcdefg, [abcdefg]>15, длина=[abcdefg]

кодирование длин 128..3839 (0080..0EFF):
%0110000abcdefg<byte>, [abcdefg]<15, длина=[abcdefg]*256+<byte>


После кода длины идёт код смещения:

 %11ab<byte>..%11abcdefgh<byte>, выбрать ab..abcdefgh из битов (в зависимости от длины расширяющейся ссылки),
                                 смещение [ abcdefgh | 1abcdefg | 11abcdef | ... | 111111ab ]*256+<byte>,
                                 последовательность ab ... abcdefgh НЕ МОЖЕТ быть вся из единичных битов,
                                 смещения 0000..FDFF,
 %00<byte>, смещение FE00+<byte>,
 %01<byte>, смещения FF00+<byte> (FF00..FFDF, <byte>=00..DF),
 %10abcde, смещение FFE0+[abcde].

6.1. Расширение расширяющейся ссылки: код %00110<FE>, только до длины 8 бит! Изначально длина расширяющейся ссылки 2 бита.


7. Код остановки распаковки

%01100000001111.


8. Избыточность кода

8.1. Стандартное кодирование смещения для длин >=4 может перескочить на вставную ссылку (%01<byte>, byte >= E0),
что бессмысленно (то же самое можно закодировать короче).

8.2. Если биты расширяемой ссылки окажутся все 1, то произойдёт глюк-ссылка и рассинхронизация входного потока,
приводящая к катастрофе с распаковываемыми данными.

Потому в пакерах запрещается генерировать такие ссылки, а в депакерах - по возможности такое отлавливать и пресекать
(вываливаться с ошибкой).

